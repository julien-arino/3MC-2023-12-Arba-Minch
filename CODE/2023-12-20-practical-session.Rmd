---
title: "Arba Minch practical session"
author: "Julien Arino"
date: "2023-12-20"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, include = FALSE)

# During the course, I may not have the data, so I will turn this off.
ONLINE = FALSE

# Load/install some libraries we may need
if (!require(WHO)) {
  # Download WHO package tarball from CRAN archive since it was removed
  url <- "https://cran.r-project.org/src/contrib/Archive/WHO/WHO_0.2.1.tar.gz"
  pkgFile <- "WHO_0.2.1.tar.gz"
  download.file(url = url, destfile = pkgFile)
  # Install package (no dependencies here)
  install.packages(pkgs=pkgFile, type="source", repos=NULL)
  # Delete package tarball
  unlink(pkgFile)
  # Load library
  library(WHO)
}
# if (!require(kableExtra)) {
#   # There is a problem with the current version of kableExtra, so we install a patched
#   # version from GitHub. You will need the package devtools installed for this.
#   devtools::install_github("kupietz/kableExtra")
#   library(kableExtra)
# }

# Rather than write separate code for each, go through each required package and install
# if needed
required_packages = c("wbstats", "dplyr", "deSolve", "GillespieSSA2")
for (pack in required_packages) {
  if (!require(pack, character.only = TRUE)) {
    install.packages(pack)
    library(pack, character.only = TRUE)
  }
}
```

Note: just before the pandemic, I published a paper on "being data aware" in mathematical epidemiology. You can find it [here](). I also put a copy on the GitHub repo. Note that you should really look at the code of that paper, which has its [own repository](https://github.com/julien-arino/modelling-with-data), as the publisher did a very bad job of rendering the file.

## Getting some data online

You can get some WHO data about Ethiopia from [here](https://data.who.int/countries/231), which will point you back [here](https://www.who.int/data/gho/data/themes/mortality-and-global-health-estimates/ghe-leading-causes-of-death) for leading causes of death.

Let us see, however, if we can get the data directly from R. Two libraries may prove useful: `WHO` (but this was "removed for policy violation", so who knows) and `wbstats`, which gets data from the World Bank.

```{r get_data}
if (ONLINE) {
  # WHO data sets
  WHO_data_sets <- get_codes()
  saveRDS(WHO_data_sets, "DATA/WHO_data_sets.rds")
  # World Bank data sets
  WB_data_sets <- wbstats::wb_indicators()
  saveRDS(WB_data_sets, "DATA/WB_data_sets.rds")
} else {
  WHO_data_sets <- readRDS("DATA/WHO_data_sets.rds")
  WB_data_sets <- readRDS("DATA/WB_data_sets.rds")
}
```

### WHO data sets

```{r display_WHO_data, include=TRUE}
kableExtra::kbl(WHO_data_sets$display) %>%
  kableExtra::scroll_box(height = "100px")
```

### World Bank data sets

```{r display_WB_data, include=TRUE}
kableExtra::kbl(head(WB_data_sets$indicator_desc, 20)) %>%
  kableExtra::scroll_box(height = "300px")
```

### We need to find the right data set

Those data sets are huge: there are `r nrow(WHO_data_sets)` data sets in the WHO data, and `r nrow(WB_data_sets)` in the World Bank data. We need to find the right one. Let us look for example for the word "mortality" in both data sets and see what we get.

```{r find_mortality, include=TRUE}
idx_mortablity_WHO = union(
  grep("mortality", WHO_data_sets$display, ignore.case = TRUE),
  grep("death", WHO_data_sets$display, ignore.case = TRUE))
idx_mortablity_WB = union(
  grep("mortality", WB_data_sets$indicator_desc, ignore.case = TRUE),
  grep("death", WB_data_sets$indicator_desc, ignore.case = TRUE))
```

Display the indices we found. First, from WHO

```{r display_mortality_WHO, include=TRUE}
kableExtra::kbl(WHO_data_sets$display[idx_mortablity_WHO]) %>%
  kableExtra::scroll_box(height = "100px")
```

Then World Bank

```{r display_mortality_WB, include=TRUE}
kableExtra::kbl(WB_data_sets$indicator_desc[idx_mortablity_WB]) %>%
  kableExtra::scroll_box(height = "100px")
```

You see the idea... Most of the epidemiologicalm data in WB comes from WHO and we could just skip the WB data but from the experience on 2023-12-20, we had better use that data set.

```{r}
idx_TB_WB = grep("tuberculosis", WB_data_sets$indicator_desc, ignore.case = TRUE)
```

Display the indices we found.

```{r display_TB_WHO, include=TRUE}
kableExtra::kbl(WB_data_sets[idx_TB_WB,]) %>%
  kableExtra::scroll_box(height = "100px")
```

```{r}
if (ONLINE) {
  TB_data_incidence = wb_data("SH.TBS.INCD", return_wide = FALSE) %>%
    filter(country == "Ethiopia")
  saveRDS(TB_data_incidence, "DATA/TB_data_incidence.Rds")
  TB_data_mortality = wb_data("SH.TBS.MORT", return_wide = FALSE) %>%
    filter(country == "Ethiopia")
  saveRDS(TB_data_mortality, "DATA/TB_data_mortality.Rds")
  TB_data_prevalence = wb_data("SH.TBS.PREV", return_wide = FALSE) %>%
    filter(country == "Ethiopia")
  saveRDS(TB_data_prevalence, "DATA/TB_data_prevalence.Rds")
  TB_data_cure = wb_data("SH.TBS.CURE.ZS", return_wide = FALSE) %>%
    filter(country == "Ethiopia")
  saveRDS(TB_data_cure, "DATA/TB_data_cure.Rds")
  TB_data_detection = wb_data("SH.TBS.DTEC.ZS", return_wide = FALSE) %>%
    filter(country == "Ethiopia")
  saveRDS(TB_data_detection, "DATA/TB_data_detection.Rds")
} else {
  TB_data_incidence = readRDS("DATA/TB_data_incidence.Rds")
  TB_data_mortality = readRDS("DATA/TB_data_mortality.Rds")
  TB_data_prevalence = readRDS("DATA/TB_data_prevalence.Rds")
  TB_data_cure = readRDS("DATA/TB_data_cure.Rds")
  TB_data_detection = readRDS("DATA/TB_data_detection.Rds")
}
# Now let's do a bit of data wrangling: make a table with all the data
TB_data = TB_data_incidence %>%
  select(date, incidence = value) %>%
  left_join(TB_data_mortality %>%
              select(date, mortality = value)) %>%
  left_join(TB_data_prevalence %>%
              select(date, prevalence = value)) %>%
  left_join(TB_data_cure %>%
              select(date, cure = value)) %>%
  left_join(TB_data_detection %>%
              select(date, detection = value)) %>%
  filter(date >= 2000) %>%
  arrange(date)
```

In the end, we have the following data set.

```{r display_TB_data, include=TRUE}
kableExtra::kbl(TB_data)%>%
  kableExtra::kable_styling()
```

# The model

We settled on the following model.

$$
\begin{aligned}
S' &= b-dS-\beta_SSI \\
L' &= \beta_SSI+\gamma_TT+\gamma_II-(d+\varepsilon+t_L)L \\
I' &= \varepsilon L+\beta_TTI-(d+\delta+\gamma_I+t_I)I \\
T' &= t_LL+t_II-\beta_TTI-(d+\gamma_T)T
\end{aligned}
$$

where $S$ is the number of susceptible individuals, $L$ the number of latently infected individuals, $I$ the number of actively infected individuals and $T$ the number of treated individuals. 
The parameters are:


..

## Computation of $\mathcal{R}_0$

Set $L=I=T=0$ and solve for $S$, giving that at the DFE, $S^\star=b/d$.
We find that 
$$
F=\begin{pmatrix}
0 & \beta_S S^\star & 0 \\
0 & 0 & 0 \\
0 & 0 & 0 
\end{pmatrix}
$$
and 
$$
V = \begin{pmatrix}
d+\varepsilon+t_L & -\gamma_I & -\gamma_T \\
-\varepsilon & d+\delta+\gamma_I+t_I & 0 \\
-t_L & 0 & d+\gamma_T
\end{pmatrix}
$$
Given the shape of $F$ and $V$, we realise that the only information we need about $V^{-1}$ is the value of the (2,1) entry.

```{r}
RHS_TB <- function(t, x, p) {
  with(as.list(c(x,p)), {
    dS <- b-d*S-beta_S*S*I
    dL <- beta_S*S*I+gamma_T*T+gamma_I*I-(d+epsilon+t_L)*L
    dI <- epsilon*L+beta_T*T*I-(d+delta+gamma_I+t_I)*I
    dT <- -beta_T*T*I-(d+gamma_T)*T+t_L*L+t_I*I
    return(list(c(dS, dL, dI, dT)))
  })
}
reactions_TB <- list(
  # propensity function effects name for reaction
  reaction("b", c(S=+1), "birth"),
  reaction("d*S", c(S=-1), "natural_death_S"),
  reaction("d*L", c(L=-1), "natural_death_L"),
  reaction("d*I", c(I=-1), "natural_death_I"),
  reaction("d*T", c(T=-1), "natural_death_T"),
  reaction("delta*I", c(I=-1), "TB_death_I"),
  reaction("beta_S*S*I", c(S=-1,I=+1), "new_infection_S_to_L"),
  reaction("beta_T*T*I", c(T=-1,I=+1), "reinfection_T_to_I"),
  reaction("epsilon*L", c(L=-1,I=+1), "L_to_I"),
  reaction("gamma_T*T", c(T=-1,L=+1), "T_to_L"),
  reaction("gamma_I*I", c(L=+1,I=-1), "I_to_L"),
  reaction("t_L*L", c(L=-1,T=+1), "treatment_L"),
  reaction("t_I*I", c(I=-1,T=+1), "treatment_I")
)
# To make things easy, work with a total population of 100K, matching the "per 100K" 
# in the data
Pop = 100000
I_0 = TB_data$incidence[1]
IC <- c(S = Pop-I_0, L = I_0*10, I = I_0, T = 0)
params <- list()
if (ONLINE) {
  # Get the most recent life expectancy value from the WB data
  params$d = 1/wb_data(indicator = "SP.DYN.LE00.IN", 
                       country = "Ethiopia", mrv = 1, return_wide = FALSE)$value
} else {
  # Most recent is 64.975 years
  params$d = 0.01539053 
}
params$b = Pop*params$d
params$beta_S = 0.00005
params$beta_T = 0.00002
params$delta = 1/200
params$epsilon = 1/500
params$gamma_T = 1/100
params$gamma_I = 1/1000
params$t_L = 1/50
params$t_I = 1/20
# Final time
params$t_f = 100

set.seed(NULL)
sol_CTMC <- ssa(
  initial_state = IC,
  reactions = reactions_TB,
  params = unlist(params),
  method = ssa_exact(),
  final_time = params$t_f,
  log_firings = TRUE    # This way we keep track of events as well
)
sol_ODE <- ode(
  y = IC,
  func = RHS_TB,
  parms = params,
  times = seq(0, params$t_f)
)
```
